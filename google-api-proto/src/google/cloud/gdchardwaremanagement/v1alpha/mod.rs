// This file is @generated by prost-build.
/// An order for GDC hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    /// Identifier. Name of this order.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name of this order.
    #[prost(string, tag = "13")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Time when this order was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this order was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this order as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of this order. On order creation, state will be set to
    /// DRAFT.
    #[prost(enumeration = "order::State", tag = "5")]
    pub state: i32,
    /// Required. Customer contact information.
    #[prost(message, optional, tag = "6")]
    pub organization_contact: ::core::option::Option<OrganizationContact>,
    /// Optional. Customer specified workloads of interest targeted by this order.
    /// This must contain <= 20 elements and the length of each element must be <=
    /// 50 characters.
    #[prost(string, repeated, tag = "7")]
    pub target_workloads: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. Information about the customer's motivation for this order. The
    /// length of this field must be <= 1000 characters.
    #[prost(string, tag = "8")]
    pub customer_motivation: ::prost::alloc::string::String,
    /// Required. Customer specified deadline by when this order should be
    /// fulfilled.
    #[prost(message, optional, tag = "9")]
    pub fulfillment_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. [Unicode CLDR](<http://cldr.unicode.org/>) region code where this
    /// order will be deployed. For a list of valid CLDR region codes, see the
    /// [Language Subtag
    /// Registry](<https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry>).
    #[prost(string, tag = "10")]
    pub region_code: ::prost::alloc::string::String,
    /// Output only. Link to the order form.
    #[prost(string, tag = "11")]
    pub order_form_uri: ::prost::alloc::string::String,
    /// Output only. Type of this Order.
    #[prost(enumeration = "order::Type", tag = "12")]
    pub r#type: i32,
    /// Output only. Time when the order was submitted. Is auto-populated to the
    /// current time when an order is submitted.
    #[prost(message, optional, tag = "14")]
    pub submit_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The Google Cloud Billing ID to be charged for this order.
    #[prost(string, tag = "15")]
    pub billing_id: ::prost::alloc::string::String,
    /// Optional. Existing hardware to be removed as part of this order.
    /// Note: any hardware removed will be recycled unless otherwise agreed.
    #[prost(message, repeated, tag = "16")]
    pub existing_hardware: ::prost::alloc::vec::Vec<HardwareLocation>,
}
/// Nested message and enum types in `Order`.
pub mod order {
    /// Valid states of an order.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the order is unspecified.
        Unspecified = 0,
        /// Order is being drafted by the customer and has not been submitted yet.
        Draft = 1,
        /// Order has been submitted to Google.
        Submitted = 2,
        /// Order has been accepted by Google.
        Accepted = 3,
        /// Order needs more information from the customer.
        AdditionalInfoNeeded = 4,
        /// Google has initiated building hardware for the order.
        Building = 5,
        /// The hardware has been built and is being shipped.
        Shipping = 6,
        /// The hardware is being installed.
        Installing = 7,
        /// An error occurred in processing the order and customer intervention is
        /// required.
        Failed = 8,
        /// Order has been partially completed i.e., some hardware have been
        /// delivered and installed.
        PartiallyCompleted = 9,
        /// Order has been completed.
        Completed = 10,
        /// Order has been cancelled.
        Cancelled = 11,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Draft => "DRAFT",
                Self::Submitted => "SUBMITTED",
                Self::Accepted => "ACCEPTED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Building => "BUILDING",
                Self::Shipping => "SHIPPING",
                Self::Installing => "INSTALLING",
                Self::Failed => "FAILED",
                Self::PartiallyCompleted => "PARTIALLY_COMPLETED",
                Self::Completed => "COMPLETED",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "SUBMITTED" => Some(Self::Submitted),
                "ACCEPTED" => Some(Self::Accepted),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "FAILED" => Some(Self::Failed),
                "PARTIALLY_COMPLETED" => Some(Self::PartiallyCompleted),
                "COMPLETED" => Some(Self::Completed),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    /// Valid types of an Order.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Type of the order is unspecified.
        Unspecified = 0,
        /// Paid by the customer.
        Paid = 1,
        /// Proof of concept for the customer.
        Poc = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Paid => "PAID",
                Self::Poc => "POC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PAID" => Some(Self::Paid),
                "POC" => Some(Self::Poc),
                _ => None,
            }
        }
    }
}
/// A physical site where hardware will be installed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Site {
    /// Identifier. Name of the site.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name of this Site.
    #[prost(string, tag = "24")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Description of this Site.
    #[prost(string, tag = "25")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Time when this site was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this site was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this site as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Contact information for this site.
    #[prost(message, optional, tag = "5")]
    pub organization_contact: ::core::option::Option<OrganizationContact>,
    /// Required. A URL to the Google Maps address location of the site.
    /// An example value is `<https://goo.gl/maps/xxxxxxxxx`.>
    #[prost(string, tag = "6")]
    pub google_maps_pin_uri: ::prost::alloc::string::String,
    /// Optional. The time periods when the site is accessible.
    /// If this field is empty, the site is accessible at all times.
    #[prost(message, repeated, tag = "26")]
    pub access_times: ::prost::alloc::vec::Vec<TimePeriod>,
    /// Optional. Any additional notes for this Site. Please include information
    /// about:
    ///   - security or access restrictions
    ///   - any regulations affecting the technicians visiting the site
    ///   - any special process or approval required to move the equipment
    ///   - whether a representative will be available during site visits
    #[prost(string, tag = "27")]
    pub notes: ::prost::alloc::string::String,
}
/// A group of hardware that is part of the same order, has the same SKU, and is
/// delivered to the same site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareGroup {
    /// Identifier. Name of this hardware group.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this hardware group was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this hardware group was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this hardware group as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Number of hardware in this HardwareGroup.
    #[prost(int32, tag = "5")]
    pub hardware_count: i32,
    /// Required. Configuration for hardware in this HardwareGroup.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<HardwareConfig>,
    /// Required. Name of the site where the hardware in this HardwareGroup will be
    /// delivered.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "7")]
    pub site: ::prost::alloc::string::String,
    /// Output only. Current state of this HardwareGroup.
    #[prost(enumeration = "hardware_group::State", tag = "8")]
    pub state: i32,
    /// Optional. Name of the zone that the hardware in this HardwareGroup belongs
    /// to. Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "9")]
    pub zone: ::prost::alloc::string::String,
    /// Optional. Requested installation date for the hardware in this
    /// HardwareGroup. Filled in by the customer.
    #[prost(message, optional, tag = "10")]
    pub requested_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
}
/// Nested message and enum types in `HardwareGroup`.
pub mod hardware_group {
    /// Valid states of a HardwareGroup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the HardwareGroup is unspecified.
        Unspecified = 0,
        /// More information is required from the customer to make progress.
        AdditionalInfoNeeded = 1,
        /// Google has initiated building hardware for this HardwareGroup.
        Building = 2,
        /// The hardware has been built and is being shipped.
        Shipping = 3,
        /// The hardware is being installed.
        Installing = 4,
        /// Some hardware in the HardwareGroup have been installed.
        PartiallyInstalled = 5,
        /// All hardware in the HardwareGroup have been installed.
        Installed = 6,
        /// An error occurred and customer intervention is required.
        Failed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Building => "BUILDING",
                Self::Shipping => "SHIPPING",
                Self::Installing => "INSTALLING",
                Self::PartiallyInstalled => "PARTIALLY_INSTALLED",
                Self::Installed => "INSTALLED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "PARTIALLY_INSTALLED" => Some(Self::PartiallyInstalled),
                "INSTALLED" => Some(Self::Installed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// An instance of hardware installed at a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hardware {
    /// Identifier. Name of this hardware.
    /// Format: `projects/{project}/locations/{location}/hardware/{hardware}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name for this hardware.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Time when this hardware was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this hardware was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this hardware as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "5")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Name of the order that this hardware belongs to.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "6")]
    pub order: ::prost::alloc::string::String,
    /// Output only. Name for the hardware group that this hardware belongs to.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "7")]
    pub hardware_group: ::prost::alloc::string::String,
    /// Required. Name for the site that this hardware belongs to.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "8")]
    pub site: ::prost::alloc::string::String,
    /// Output only. Current state for this hardware.
    #[prost(enumeration = "hardware::State", tag = "9")]
    pub state: i32,
    /// Output only. Link to the Customer Intake Questionnaire (CIQ) sheet for this
    /// Hardware.
    #[prost(string, tag = "10")]
    pub ciq_uri: ::prost::alloc::string::String,
    /// Required. Configuration for this hardware.
    #[prost(message, optional, tag = "11")]
    pub config: ::core::option::Option<HardwareConfig>,
    /// Output only. Estimated installation date for this hardware.
    #[prost(message, optional, tag = "12")]
    pub estimated_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    /// Optional. Physical properties of this hardware.
    #[prost(message, optional, tag = "13")]
    pub physical_info: ::core::option::Option<HardwarePhysicalInfo>,
    /// Optional. Information for installation of this hardware.
    #[prost(message, optional, tag = "14")]
    pub installation_info: ::core::option::Option<HardwareInstallationInfo>,
    /// Required. Name for the zone that this hardware belongs to.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "15")]
    pub zone: ::prost::alloc::string::String,
    /// Optional. Requested installation date for this hardware. This is
    /// auto-populated when the order is accepted, if the hardware's HardwareGroup
    /// specifies this. It can also be filled in by the customer.
    #[prost(message, optional, tag = "16")]
    pub requested_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
    /// Output only. Actual installation date for this hardware. Filled in by
    /// Google.
    #[prost(message, optional, tag = "17")]
    pub actual_installation_date: ::core::option::Option<
        super::super::super::r#type::Date,
    >,
}
/// Nested message and enum types in `Hardware`.
pub mod hardware {
    /// Valid states for hardware.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the Hardware is unspecified.
        Unspecified = 0,
        /// More information is required from the customer to make progress.
        AdditionalInfoNeeded = 1,
        /// Google has initiated building hardware for this Hardware.
        Building = 2,
        /// The hardware has been built and is being shipped.
        Shipping = 3,
        /// The hardware is being installed.
        Installing = 4,
        /// The hardware has been installed.
        Installed = 5,
        /// An error occurred and customer intervention is required.
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Building => "BUILDING",
                Self::Shipping => "SHIPPING",
                Self::Installing => "INSTALLING",
                Self::Installed => "INSTALLED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "BUILDING" => Some(Self::Building),
                "SHIPPING" => Some(Self::Shipping),
                "INSTALLING" => Some(Self::Installing),
                "INSTALLED" => Some(Self::Installed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// A comment on an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Comment {
    /// Identifier. Name of this comment.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/comments/{comment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this comment was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this comment as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "3")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Username of the author of this comment. This is auto-populated
    /// from the credentials used during creation of the comment.
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    /// Required. Text of this comment. The length of text must be <= 1000
    /// characters.
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
}
/// A log entry of a change made to an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeLogEntry {
    /// Identifier. Name of this change log entry.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/changeLogEntries/{change_log_entry}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this change log entry was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this change log entry as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "3")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Content of this log entry.
    #[prost(string, tag = "4")]
    pub log: ::prost::alloc::string::String,
}
/// A stock keeping unit (SKU) of GDC hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Sku {
    /// Identifier. Name of this SKU.
    /// Format: `projects/{project}/locations/{location}/skus/{sku}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Display name of this SKU.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Time when this SKU was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this SKU was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Configuration for this SKU.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<SkuConfig>,
    /// Output only. Available instances of this SKU. This field should be used for
    /// checking availability of a SKU.
    #[prost(message, repeated, tag = "7")]
    pub instances: ::prost::alloc::vec::Vec<SkuInstance>,
    /// Output only. Description of this SKU.
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The SKU revision ID.
    /// A new revision is created whenever `config` is updated. The format is an
    /// 8-character hexadecimal string.
    #[prost(string, tag = "9")]
    pub revision_id: ::prost::alloc::string::String,
    /// Output only. Flag to indicate whether or not this revision is active. Only
    /// an active revision can be used in a new Order.
    #[prost(bool, tag = "10")]
    pub is_active: bool,
    /// Output only. Type of this SKU.
    #[prost(enumeration = "sku::Type", tag = "11")]
    pub r#type: i32,
    /// Output only. The vCPU count associated with this SKU.
    #[prost(int32, tag = "12")]
    pub vcpu_count: i32,
}
/// Nested message and enum types in `Sku`.
pub mod sku {
    /// Valid types of a SKU.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Type of the SKU is unspecified. This is not an allowed value.
        Unspecified = 0,
        /// Rack SKU.
        Rack = 1,
        /// Server SKU.
        Server = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Rack => "RACK",
                Self::Server => "SERVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RACK" => Some(Self::Rack),
                "SERVER" => Some(Self::Server),
                _ => None,
            }
        }
    }
}
/// A zone holding a set of hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    /// Identifier. Name of this zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this zone was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when this zone was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels associated with this zone as key value pairs.
    /// For more information about labels, see [Create and manage
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels>).
    #[prost(btree_map = "string, string", tag = "4")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Human friendly display name of this zone.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Current state for this zone.
    #[prost(enumeration = "zone::State", tag = "8")]
    pub state: i32,
    /// Required. The points of contact.
    #[prost(message, repeated, tag = "9")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    /// Output only. Link to the Customer Intake Questionnaire (CIQ) sheet for this
    /// zone.
    #[prost(string, tag = "10")]
    pub ciq_uri: ::prost::alloc::string::String,
    /// Optional. Networking configuration for this zone.
    #[prost(message, optional, tag = "11")]
    pub network_config: ::core::option::Option<ZoneNetworkConfig>,
    /// Output only. Globally unique identifier generated for this Edge Zone.
    #[prost(string, tag = "12")]
    pub globally_unique_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    /// Valid states for a zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State of the Zone is unspecified.
        Unspecified = 0,
        /// More information is required from the customer to make progress.
        AdditionalInfoNeeded = 1,
        /// Google is preparing the Zone.
        Preparing = 2,
        /// Factory turnup has succeeded.
        ReadyForCustomerFactoryTurnupChecks = 5,
        /// The Zone is ready for site turnup.
        ReadyForSiteTurnup = 6,
        /// The Zone failed in factory turnup checks.
        CustomerFactoryTurnupChecksFailed = 7,
        /// The Zone is available to use.
        Active = 3,
        /// The Zone has been cancelled.
        Cancelled = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AdditionalInfoNeeded => "ADDITIONAL_INFO_NEEDED",
                Self::Preparing => "PREPARING",
                Self::ReadyForCustomerFactoryTurnupChecks => {
                    "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS"
                }
                Self::ReadyForSiteTurnup => "READY_FOR_SITE_TURNUP",
                Self::CustomerFactoryTurnupChecksFailed => {
                    "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED"
                }
                Self::Active => "ACTIVE",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDITIONAL_INFO_NEEDED" => Some(Self::AdditionalInfoNeeded),
                "PREPARING" => Some(Self::Preparing),
                "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS" => {
                    Some(Self::ReadyForCustomerFactoryTurnupChecks)
                }
                "READY_FOR_SITE_TURNUP" => Some(Self::ReadyForSiteTurnup),
                "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED" => {
                    Some(Self::CustomerFactoryTurnupChecksFailed)
                }
                "ACTIVE" => Some(Self::Active),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// Contact information of the customer organization.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationContact {
    /// Required. The organization's address.
    #[prost(message, optional, tag = "1")]
    pub address: ::core::option::Option<super::super::super::r#type::PostalAddress>,
    /// Optional. The organization's email.
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    /// Optional. The organization's phone number.
    #[prost(string, tag = "3")]
    pub phone: ::prost::alloc::string::String,
    /// Required. The individual points of contact in the organization at this
    /// location.
    #[prost(message, repeated, tag = "4")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
/// Contact details of a point of contact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    /// Required. Given name of the contact.
    #[prost(string, tag = "1")]
    pub given_name: ::prost::alloc::string::String,
    /// Optional. Family name of the contact.
    #[prost(string, tag = "2")]
    pub family_name: ::prost::alloc::string::String,
    /// Required. Email of the contact.
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    /// Required. Phone number of the contact.
    #[prost(string, tag = "4")]
    pub phone: ::prost::alloc::string::String,
    /// Optional. Time zone of the contact.
    #[prost(message, optional, tag = "5")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Optional. The time periods when the contact is reachable.
    /// If this field is empty, the contact is reachable at all times.
    #[prost(message, repeated, tag = "6")]
    pub reachable_times: ::prost::alloc::vec::Vec<TimePeriod>,
}
/// Configuration for GDC hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareConfig {
    /// Required. Reference to the SKU for this hardware. This can point to a
    /// specific SKU revision in the form of `resource_name@revision_id` as defined
    /// in [AIP-162](<https://google.aip.dev/162>). If no revision_id is specified,
    /// it refers to the latest revision.
    #[prost(string, tag = "1")]
    pub sku: ::prost::alloc::string::String,
    /// Required. Power supply type for this hardware.
    #[prost(enumeration = "PowerSupply", tag = "2")]
    pub power_supply: i32,
    /// Optional. Subscription duration for the hardware in months.
    #[prost(int32, tag = "3")]
    pub subscription_duration_months: i32,
}
/// Configuration for a SKU.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuConfig {
    /// Information about CPU configuration.
    #[prost(string, tag = "1")]
    pub cpu: ::prost::alloc::string::String,
    /// Information about GPU configuration.
    #[prost(string, tag = "2")]
    pub gpu: ::prost::alloc::string::String,
    /// Information about RAM configuration.
    #[prost(string, tag = "3")]
    pub ram: ::prost::alloc::string::String,
    /// Information about storage configuration.
    #[prost(string, tag = "4")]
    pub storage: ::prost::alloc::string::String,
}
/// A specific instance of the SKU.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkuInstance {
    /// The [Unicode CLDR](<https://cldr.unicode.org>) region code where this
    /// instance is available.
    #[prost(string, tag = "1")]
    pub region_code: ::prost::alloc::string::String,
    /// Power supply type for this instance.
    #[prost(enumeration = "PowerSupply", tag = "2")]
    pub power_supply: i32,
    /// Reference to the corresponding SKU in the Cloud Billing API.
    /// The estimated price information can be retrieved using that API.
    /// Format: `services/{service}/skus/{sku}`
    #[prost(string, tag = "3")]
    pub billing_sku: ::prost::alloc::string::String,
    /// Reference to the corresponding SKU per vCPU in the Cloud Billing API.
    /// The estimated price information can be retrieved using that API.
    /// Format: `services/{service}/skus/{sku}`
    #[prost(string, tag = "4")]
    pub billing_sku_per_vcpu: ::prost::alloc::string::String,
    /// Subscription duration for the hardware in months.
    #[prost(int32, tag = "5")]
    pub subscription_duration_months: i32,
}
/// Physical properties of a hardware.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HardwarePhysicalInfo {
    /// Required. The power receptacle type.
    #[prost(enumeration = "hardware_physical_info::PowerReceptacleType", tag = "1")]
    pub power_receptacle: i32,
    /// Required. Type of the uplink network connection.
    #[prost(enumeration = "hardware_physical_info::NetworkUplinkType", tag = "2")]
    pub network_uplink: i32,
    /// Required. Voltage of the power supply.
    #[prost(enumeration = "hardware_physical_info::Voltage", tag = "3")]
    pub voltage: i32,
    /// Required. Amperes of the power supply.
    #[prost(enumeration = "hardware_physical_info::Amperes", tag = "4")]
    pub amperes: i32,
}
/// Nested message and enum types in `HardwarePhysicalInfo`.
pub mod hardware_physical_info {
    /// Valid power receptacle types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PowerReceptacleType {
        /// Facility plug type is unspecified.
        Unspecified = 0,
        /// NEMA 5-15.
        Nema515 = 1,
        /// C13.
        C13 = 2,
        /// Standard european receptacle.
        StandardEu = 3,
    }
    impl PowerReceptacleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "POWER_RECEPTACLE_TYPE_UNSPECIFIED",
                Self::Nema515 => "NEMA_5_15",
                Self::C13 => "C_13",
                Self::StandardEu => "STANDARD_EU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "POWER_RECEPTACLE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEMA_5_15" => Some(Self::Nema515),
                "C_13" => Some(Self::C13),
                "STANDARD_EU" => Some(Self::StandardEu),
                _ => None,
            }
        }
    }
    /// Valid network uplink types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkUplinkType {
        /// Network uplink type is unspecified.
        Unspecified = 0,
        /// RJ-45.
        Rj45 = 1,
    }
    impl NetworkUplinkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NETWORK_UPLINK_TYPE_UNSPECIFIED",
                Self::Rj45 => "RJ_45",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NETWORK_UPLINK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RJ_45" => Some(Self::Rj45),
                _ => None,
            }
        }
    }
    /// Valid voltage values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Voltage {
        /// Voltage is unspecified.
        Unspecified = 0,
        /// 120V.
        Voltage110 = 1,
        /// 220V.
        Voltage220 = 3,
    }
    impl Voltage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VOLTAGE_UNSPECIFIED",
                Self::Voltage110 => "VOLTAGE_110",
                Self::Voltage220 => "VOLTAGE_220",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOLTAGE_UNSPECIFIED" => Some(Self::Unspecified),
                "VOLTAGE_110" => Some(Self::Voltage110),
                "VOLTAGE_220" => Some(Self::Voltage220),
                _ => None,
            }
        }
    }
    /// Valid amperes values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Amperes {
        /// Amperes is unspecified.
        Unspecified = 0,
        /// 15A.
        Amperes15 = 1,
    }
    impl Amperes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AMPERES_UNSPECIFIED",
                Self::Amperes15 => "AMPERES_15",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AMPERES_UNSPECIFIED" => Some(Self::Unspecified),
                "AMPERES_15" => Some(Self::Amperes15),
                _ => None,
            }
        }
    }
}
/// Information for installation of a Hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareInstallationInfo {
    /// Optional. Location of the rack in the site e.g. Floor 2, Room 201, Row 7,
    /// Rack 3.
    #[prost(string, tag = "1")]
    pub rack_location: ::prost::alloc::string::String,
    /// Required. Distance from the power outlet in meters.
    #[prost(int32, tag = "2")]
    pub power_distance_meters: i32,
    /// Required. Distance from the network switch in meters.
    #[prost(int32, tag = "3")]
    pub switch_distance_meters: i32,
    /// Required. Dimensions of the rack unit.
    #[prost(message, optional, tag = "4")]
    pub rack_unit_dimensions: ::core::option::Option<Dimensions>,
    /// Required. Rack space allocated for the hardware.
    #[prost(message, optional, tag = "5")]
    pub rack_space: ::core::option::Option<RackSpace>,
    /// Required. Type of the rack.
    #[prost(enumeration = "hardware_installation_info::RackType", tag = "6")]
    pub rack_type: i32,
}
/// Nested message and enum types in `HardwareInstallationInfo`.
pub mod hardware_installation_info {
    /// Valid rack types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RackType {
        /// Rack type is unspecified.
        Unspecified = 0,
        /// Two post rack.
        TwoPost = 1,
        /// Four post rack.
        FourPost = 2,
    }
    impl RackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RACK_TYPE_UNSPECIFIED",
                Self::TwoPost => "TWO_POST",
                Self::FourPost => "FOUR_POST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RACK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TWO_POST" => Some(Self::TwoPost),
                "FOUR_POST" => Some(Self::FourPost),
                _ => None,
            }
        }
    }
}
/// Networking configuration for a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneNetworkConfig {
    /// Required. An IPv4 address block for machine management.
    /// Should be a private RFC1918 or public CIDR block large enough to allocate
    /// at least one address per machine in the Zone.
    /// Should be in `management_ipv4_subnet`, and disjoint with other address
    /// ranges.
    #[prost(string, tag = "1")]
    pub machine_mgmt_ipv4_range: ::prost::alloc::string::String,
    /// Required. An IPv4 address block for kubernetes nodes.
    /// Should be a private RFC1918 or public CIDR block large enough to allocate
    /// at least one address per machine in the Zone.
    /// Should be in `kubernetes_ipv4_subnet`, and disjoint with other address
    /// ranges.
    #[prost(string, tag = "2")]
    pub kubernetes_node_ipv4_range: ::prost::alloc::string::String,
    /// Required. An IPv4 address block for kubernetes control plane.
    /// Should be a private RFC1918 or public CIDR block large enough to allocate
    /// at least one address per cluster in the Zone.
    /// Should be in `kubernetes_ipv4_subnet`, and disjoint with other address
    /// ranges.
    #[prost(string, tag = "3")]
    pub kubernetes_control_plane_ipv4_range: ::prost::alloc::string::String,
    /// Required. An IPv4 subnet for the management network.
    #[prost(message, optional, tag = "4")]
    pub management_ipv4_subnet: ::core::option::Option<Subnet>,
    /// Optional. An IPv4 subnet for the kubernetes network.
    /// If unspecified, the kubernetes subnet will be the same as the management
    /// subnet.
    #[prost(message, optional, tag = "5")]
    pub kubernetes_ipv4_subnet: ::core::option::Option<Subnet>,
}
/// Represents a subnet.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnet {
    /// Required. Address range for this subnet in CIDR notation.
    #[prost(string, tag = "1")]
    pub address_range: ::prost::alloc::string::String,
    /// Required. Default gateway for this subnet.
    #[prost(string, tag = "2")]
    pub default_gateway_ip_address: ::prost::alloc::string::String,
}
/// Represents a time period in a week.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimePeriod {
    /// Required. The start of the time period.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Required. The end of the time period.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Required. The days of the week that the time period is active.
    #[prost(
        enumeration = "super::super::super::r#type::DayOfWeek",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub days: ::prost::alloc::vec::Vec<i32>,
}
/// Represents the dimensions of an object.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Dimensions {
    /// Required. Width in inches.
    #[prost(float, tag = "1")]
    pub width_inches: f32,
    /// Required. Height in inches.
    #[prost(float, tag = "2")]
    pub height_inches: f32,
    /// Required. Depth in inches.
    #[prost(float, tag = "3")]
    pub depth_inches: f32,
}
/// Represents contiguous space in a rack.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RackSpace {
    /// Required. First rack unit of the rack space (inclusive).
    #[prost(int32, tag = "1")]
    pub start_rack_unit: i32,
    /// Required. Last rack unit of the rack space (inclusive).
    #[prost(int32, tag = "2")]
    pub end_rack_unit: i32,
}
/// Represents the location of one or many hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HardwareLocation {
    /// Required. Name of the site where the hardware are present.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub site: ::prost::alloc::string::String,
    /// Required. Location of the rack in the site e.g. Floor 2, Room 201, Row 7,
    /// Rack 3.
    #[prost(string, tag = "2")]
    pub rack_location: ::prost::alloc::string::String,
    /// Optional. Spaces occupied by the hardware in the rack.
    /// If unset, this location is assumed to be the entire rack.
    #[prost(message, repeated, tag = "3")]
    pub rack_space: ::prost::alloc::vec::Vec<RackSpace>,
}
/// The power supply options.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PowerSupply {
    /// Power supply is unspecified.
    Unspecified = 0,
    /// AC power supply.
    Ac = 1,
    /// DC power supply.
    Dc = 2,
}
impl PowerSupply {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "POWER_SUPPLY_UNSPECIFIED",
            Self::Ac => "POWER_SUPPLY_AC",
            Self::Dc => "POWER_SUPPLY_DC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POWER_SUPPLY_UNSPECIFIED" => Some(Self::Unspecified),
            "POWER_SUPPLY_AC" => Some(Self::Ac),
            "POWER_SUPPLY_DC" => Some(Self::Dc),
            _ => None,
        }
    }
}
/// A request to list orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersRequest {
    /// Required. The project and location to list orders in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of orders.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersResponse {
    /// The list of orders.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrderRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOrderRequest {
    /// Required. The project and location to create the order in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Order within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The order.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub order_id: ::prost::alloc::string::String,
    /// Required. The order to create.
    #[prost(message, optional, tag = "3")]
    pub order: ::core::option::Option<Order>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOrderRequest {
    /// Required. A mask to specify the fields in the Order to overwrite with this
    /// update. The fields specified in the update_mask are relative to the order,
    /// not the full request. A field will be overwritten if it is in the mask. If
    /// you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The order to update.
    #[prost(message, optional, tag = "2")]
    pub order: ::core::option::Option<Order>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteOrderRequest {
    /// Required. The name of the order.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. An option to delete any nested resources in the Order, such as a
    /// HardwareGroup. If true, any nested resources for this Order will also be
    /// deleted. Otherwise, the request will only succeed if the Order has no
    /// nested resources.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// A request to submit an order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOrderRequest {
    /// Required. The name of the order.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list sites.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesRequest {
    /// Required. The project and location to list sites in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of sites.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesResponse {
    /// The list of sites.
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSiteRequest {
    /// Required. The name of the site.
    /// Format: `projects/{project}/locations/{location}/sites/{site}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSiteRequest {
    /// Required. The project and location to create the site in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Site within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The site.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub site_id: ::prost::alloc::string::String,
    /// Required. The site to create.
    #[prost(message, optional, tag = "3")]
    pub site: ::core::option::Option<Site>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update a site.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSiteRequest {
    /// Required. A mask to specify the fields in the Site to overwrite with this
    /// update. The fields specified in the update_mask are relative to the site,
    /// not the full request. A field will be overwritten if it is in the mask. If
    /// you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The site to update.
    #[prost(message, optional, tag = "2")]
    pub site: ::core::option::Option<Site>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list hardware groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareGroupsRequest {
    /// Required. The order to list hardware groups in.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of hardware groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareGroupsResponse {
    /// The list of hardware groups.
    #[prost(message, repeated, tag = "1")]
    pub hardware_groups: ::prost::alloc::vec::Vec<HardwareGroup>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareGroupRequest {
    /// Required. The name of the hardware group.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHardwareGroupRequest {
    /// Required. The order to create the hardware group in.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the HardwareGroup within its parent
    /// scope. This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The hardware_group.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub hardware_group_id: ::prost::alloc::string::String,
    /// Required. The hardware group to create.
    #[prost(message, optional, tag = "3")]
    pub hardware_group: ::core::option::Option<HardwareGroup>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHardwareGroupRequest {
    /// Required. A mask to specify the fields in the HardwareGroup to overwrite
    /// with this update. The fields specified in the update_mask are relative to
    /// the hardware group, not the full request. A field will be overwritten if it
    /// is in the mask. If you don't provide a mask then all fields will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The hardware group to update.
    #[prost(message, optional, tag = "2")]
    pub hardware_group: ::core::option::Option<HardwareGroup>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete a hardware group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHardwareGroupRequest {
    /// Required. The name of the hardware group.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareRequest {
    /// Required. The project and location to list hardware in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHardwareResponse {
    /// The list of hardware.
    #[prost(message, repeated, tag = "1")]
    pub hardware: ::prost::alloc::vec::Vec<Hardware>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHardwareRequest {
    /// Required. The name of the hardware.
    /// Format: `projects/{project}/locations/{location}/hardware/{hardware}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHardwareRequest {
    /// Required. The project and location to create hardware in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Hardware within its parent
    /// scope. This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The hardware.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub hardware_id: ::prost::alloc::string::String,
    /// Required. The resource to create.
    #[prost(message, optional, tag = "3")]
    pub hardware: ::core::option::Option<Hardware>,
}
/// A request to update hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHardwareRequest {
    /// Required. A mask to specify the fields in the Hardware to overwrite with
    /// this update. The fields specified in the update_mask are relative to the
    /// hardware, not the full request. A field will be overwritten if it is in the
    /// mask. If you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The hardware to update.
    #[prost(message, optional, tag = "2")]
    pub hardware: ::core::option::Option<Hardware>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete hardware.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHardwareRequest {
    /// Required. The name of the hardware.
    /// Format: `projects/{project}/locations/{location}/hardware/{hardware}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsRequest {
    /// Required. The order to list comments on.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A request to list comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsResponse {
    /// The list of comments.
    #[prost(message, repeated, tag = "1")]
    pub comments: ::prost::alloc::vec::Vec<Comment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommentRequest {
    /// Required. The name of the comment.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/comments/{comment}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCommentRequest {
    /// Required. The order to create the comment on.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Comment within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The comment.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub comment_id: ::prost::alloc::string::String,
    /// Required. The comment to create.
    #[prost(message, optional, tag = "3")]
    pub comment: ::core::option::Option<Comment>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to list change log entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeLogEntriesRequest {
    /// Required. The order to list change log entries for.
    /// Format: `projects/{project}/locations/{location}/orders/{order}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of change log entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChangeLogEntriesResponse {
    /// The list of change log entries.
    #[prost(message, repeated, tag = "1")]
    pub change_log_entries: ::prost::alloc::vec::Vec<ChangeLogEntry>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a change log entry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChangeLogEntryRequest {
    /// Required. The name of the change log entry.
    /// Format:
    /// `projects/{project}/locations/{location}/orders/{order}/changeLogEntries/{change_log_entry}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list SKUs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusRequest {
    /// Required. The project and location to list SKUs in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of SKUs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkusResponse {
    /// The list of SKUs.
    #[prost(message, repeated, tag = "1")]
    pub skus: ::prost::alloc::vec::Vec<Sku>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get an SKU.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSkuRequest {
    /// Required. The name of the SKU.
    /// Format: `projects/{project}/locations/{location}/skus/{sku}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to list zones.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesRequest {
    /// Required. The project and location to list zones in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering condition. See [AIP-160](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// A list of zones.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesResponse {
    /// The list of zones.
    #[prost(message, repeated, tag = "1")]
    pub zones: ::prost::alloc::vec::Vec<Zone>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A request to get a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneRequest {
    /// Required. The name of the zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to create a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateZoneRequest {
    /// Required. The project and location to create the zone in.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. ID used to uniquely identify the Zone within its parent scope.
    /// This field should contain at most 63 characters and must start with
    /// lowercase characters.
    /// Only lowercase characters, numbers and `-` are accepted.
    /// The `-` character cannot be the first or the last one.
    /// A system generated ID will be used if the field is not set.
    ///
    /// The zone.name field in the request will be ignored.
    #[prost(string, tag = "2")]
    pub zone_id: ::prost::alloc::string::String,
    /// Required. The zone to create.
    #[prost(message, optional, tag = "3")]
    pub zone: ::core::option::Option<Zone>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to update a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateZoneRequest {
    /// Required. A mask to specify the fields in the Zone to overwrite with this
    /// update. The fields specified in the update_mask are relative to the zone,
    /// not the full request. A field will be overwritten if it is in the mask. If
    /// you don't provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The zone to update.
    #[prost(message, optional, tag = "2")]
    pub zone: ::core::option::Option<Zone>,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to delete a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteZoneRequest {
    /// Required. The name of the zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A request to signal the state of a zone.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalZoneStateRequest {
    /// Required. The name of the zone.
    /// Format: `projects/{project}/locations/{location}/zones/{zone}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional unique identifier for this request. See
    /// [AIP-155](<https://google.aip.dev/155>).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Required. The state signal to send for this zone.
    #[prost(enumeration = "signal_zone_state_request::StateSignal", tag = "3")]
    pub state_signal: i32,
}
/// Nested message and enum types in `SignalZoneStateRequest`.
pub mod signal_zone_state_request {
    /// Valid state signals for a zone.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StateSignal {
        /// State signal of the zone is unspecified.
        Unspecified = 0,
        /// The Zone is ready for site turnup.
        ReadyForSiteTurnup = 1,
        /// The Zone failed in factory turnup checks.
        FactoryTurnupChecksFailed = 2,
    }
    impl StateSignal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_SIGNAL_UNSPECIFIED",
                Self::ReadyForSiteTurnup => "READY_FOR_SITE_TURNUP",
                Self::FactoryTurnupChecksFailed => "FACTORY_TURNUP_CHECKS_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_SIGNAL_UNSPECIFIED" => Some(Self::Unspecified),
                "READY_FOR_SITE_TURNUP" => Some(Self::ReadyForSiteTurnup),
                "FACTORY_TURNUP_CHECKS_FAILED" => Some(Self::FactoryTurnupChecksFailed),
                _ => None,
            }
        }
    }
}
/// Represents the metadata of a long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. The verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod gdc_hardware_management_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GDC Hardware Management service.
    #[derive(Debug, Clone)]
    pub struct GdcHardwareManagementClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GdcHardwareManagementClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GdcHardwareManagementClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GdcHardwareManagementClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists orders in a given project and location.
        pub async fn list_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrdersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListOrders",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of an order.
        pub async fn get_order(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::Order>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new order in a given project and location.
        pub async fn create_order(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of an order.
        pub async fn update_order(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an order.
        pub async fn delete_order(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits an order.
        pub async fn submit_order(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SubmitOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "SubmitOrder",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists sites in a given project and location.
        pub async fn list_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a site.
        pub async fn get_site(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new site in a given project and location.
        pub async fn create_site(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a site.
        pub async fn update_site(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hardware groups in a given order.
        pub async fn list_hardware_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHardwareGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardwareGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListHardwareGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a hardware group.
        pub async fn get_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::HardwareGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new hardware group in a given order.
        pub async fn create_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a hardware group.
        pub async fn update_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a hardware group.
        pub async fn delete_hardware_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardwareGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteHardwareGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hardware in a given project and location.
        pub async fn list_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets hardware details.
        pub async fn get_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHardwareRequest>,
        ) -> std::result::Result<tonic::Response<super::Hardware>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates new hardware in a given project and location.
        pub async fn create_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates hardware parameters.
        pub async fn update_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes hardware.
        pub async fn delete_hardware(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardware",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteHardware",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the comments on an order.
        pub async fn list_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the content of a comment.
        pub async fn get_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new comment on an order.
        pub async fn create_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the changes made to an order.
        pub async fn list_change_log_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChangeLogEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChangeLogEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListChangeLogEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListChangeLogEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a change to an order.
        pub async fn get_change_log_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChangeLogEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ChangeLogEntry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetChangeLogEntry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetChangeLogEntry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SKUs for a given project and location.
        pub async fn list_skus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSkus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListSkus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of an SKU.
        pub async fn get_sku(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSkuRequest>,
        ) -> std::result::Result<tonic::Response<super::Sku>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSku",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetSku",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists zones in a given project and location.
        pub async fn list_zones(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZonesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListZonesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListZones",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "ListZones",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a zone.
        pub async fn get_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "GetZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new zone in a given project and location.
        pub async fn create_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "CreateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a zone.
        pub async fn update_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "UpdateZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a zone.
        pub async fn delete_zone(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteZone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "DeleteZone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Signals the state of a zone.
        pub async fn signal_zone_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalZoneStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SignalZoneState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement",
                        "SignalZoneState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod gdc_hardware_management_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GdcHardwareManagementServer.
    #[async_trait]
    pub trait GdcHardwareManagement: std::marker::Send + std::marker::Sync + 'static {
        /// Lists orders in a given project and location.
        async fn list_orders(
            &self,
            request: tonic::Request<super::ListOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrdersResponse>,
            tonic::Status,
        >;
        /// Gets details of an order.
        async fn get_order(
            &self,
            request: tonic::Request<super::GetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::Order>, tonic::Status>;
        /// Creates a new order in a given project and location.
        async fn create_order(
            &self,
            request: tonic::Request<super::CreateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Updates the parameters of an order.
        async fn update_order(
            &self,
            request: tonic::Request<super::UpdateOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes an order.
        async fn delete_order(
            &self,
            request: tonic::Request<super::DeleteOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Submits an order.
        async fn submit_order(
            &self,
            request: tonic::Request<super::SubmitOrderRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists sites in a given project and location.
        async fn list_sites(
            &self,
            request: tonic::Request<super::ListSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSitesResponse>,
            tonic::Status,
        >;
        /// Gets details of a site.
        async fn get_site(
            &self,
            request: tonic::Request<super::GetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status>;
        /// Creates a new site in a given project and location.
        async fn create_site(
            &self,
            request: tonic::Request<super::CreateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Updates the parameters of a site.
        async fn update_site(
            &self,
            request: tonic::Request<super::UpdateSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists hardware groups in a given order.
        async fn list_hardware_groups(
            &self,
            request: tonic::Request<super::ListHardwareGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareGroupsResponse>,
            tonic::Status,
        >;
        /// Gets details of a hardware group.
        async fn get_hardware_group(
            &self,
            request: tonic::Request<super::GetHardwareGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::HardwareGroup>, tonic::Status>;
        /// Creates a new hardware group in a given order.
        async fn create_hardware_group(
            &self,
            request: tonic::Request<super::CreateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Updates the parameters of a hardware group.
        async fn update_hardware_group(
            &self,
            request: tonic::Request<super::UpdateHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes a hardware group.
        async fn delete_hardware_group(
            &self,
            request: tonic::Request<super::DeleteHardwareGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists hardware in a given project and location.
        async fn list_hardware(
            &self,
            request: tonic::Request<super::ListHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHardwareResponse>,
            tonic::Status,
        >;
        /// Gets hardware details.
        async fn get_hardware(
            &self,
            request: tonic::Request<super::GetHardwareRequest>,
        ) -> std::result::Result<tonic::Response<super::Hardware>, tonic::Status>;
        /// Creates new hardware in a given project and location.
        async fn create_hardware(
            &self,
            request: tonic::Request<super::CreateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Updates hardware parameters.
        async fn update_hardware(
            &self,
            request: tonic::Request<super::UpdateHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes hardware.
        async fn delete_hardware(
            &self,
            request: tonic::Request<super::DeleteHardwareRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists the comments on an order.
        async fn list_comments(
            &self,
            request: tonic::Request<super::ListCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCommentsResponse>,
            tonic::Status,
        >;
        /// Gets the content of a comment.
        async fn get_comment(
            &self,
            request: tonic::Request<super::GetCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status>;
        /// Creates a new comment on an order.
        async fn create_comment(
            &self,
            request: tonic::Request<super::CreateCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Lists the changes made to an order.
        async fn list_change_log_entries(
            &self,
            request: tonic::Request<super::ListChangeLogEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChangeLogEntriesResponse>,
            tonic::Status,
        >;
        /// Gets details of a change to an order.
        async fn get_change_log_entry(
            &self,
            request: tonic::Request<super::GetChangeLogEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::ChangeLogEntry>, tonic::Status>;
        /// Lists SKUs for a given project and location.
        async fn list_skus(
            &self,
            request: tonic::Request<super::ListSkusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSkusResponse>,
            tonic::Status,
        >;
        /// Gets details of an SKU.
        async fn get_sku(
            &self,
            request: tonic::Request<super::GetSkuRequest>,
        ) -> std::result::Result<tonic::Response<super::Sku>, tonic::Status>;
        /// Lists zones in a given project and location.
        async fn list_zones(
            &self,
            request: tonic::Request<super::ListZonesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListZonesResponse>,
            tonic::Status,
        >;
        /// Gets details of a zone.
        async fn get_zone(
            &self,
            request: tonic::Request<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status>;
        /// Creates a new zone in a given project and location.
        async fn create_zone(
            &self,
            request: tonic::Request<super::CreateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Updates the parameters of a zone.
        async fn update_zone(
            &self,
            request: tonic::Request<super::UpdateZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Deletes a zone.
        async fn delete_zone(
            &self,
            request: tonic::Request<super::DeleteZoneRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
        /// Signals the state of a zone.
        async fn signal_zone_state(
            &self,
            request: tonic::Request<super::SignalZoneStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        >;
    }
    /// The GDC Hardware Management service.
    #[derive(Debug)]
    pub struct GdcHardwareManagementServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> GdcHardwareManagementServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for GdcHardwareManagementServer<T>
    where
        T: GdcHardwareManagement,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListOrders" => {
                    #[allow(non_camel_case_types)]
                    struct ListOrdersSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListOrdersRequest>
                    for ListOrdersSvc<T> {
                        type Response = super::ListOrdersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListOrdersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_orders(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListOrdersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetOrder" => {
                    #[allow(non_camel_case_types)]
                    struct GetOrderSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetOrderRequest>
                    for GetOrderSvc<T> {
                        type Response = super::Order;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateOrder" => {
                    #[allow(non_camel_case_types)]
                    struct CreateOrderSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::CreateOrderRequest>
                    for CreateOrderSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::create_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateOrder" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateOrderSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::UpdateOrderRequest>
                    for UpdateOrderSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::update_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteOrder" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteOrderSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::DeleteOrderRequest>
                    for DeleteOrderSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::delete_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SubmitOrder" => {
                    #[allow(non_camel_case_types)]
                    struct SubmitOrderSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::SubmitOrderRequest>
                    for SubmitOrderSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubmitOrderRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::submit_order(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubmitOrderSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSites" => {
                    #[allow(non_camel_case_types)]
                    struct ListSitesSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListSitesRequest>
                    for ListSitesSvc<T> {
                        type Response = super::ListSitesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSitesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_sites(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSitesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSite" => {
                    #[allow(non_camel_case_types)]
                    struct GetSiteSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetSiteRequest>
                    for GetSiteSvc<T> {
                        type Response = super::Site;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSiteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_site(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSiteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateSite" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSiteSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::CreateSiteRequest>
                    for CreateSiteSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSiteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::create_site(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSiteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateSite" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateSiteSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::UpdateSiteRequest>
                    for UpdateSiteSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSiteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::update_site(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateSiteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardwareGroups" => {
                    #[allow(non_camel_case_types)]
                    struct ListHardwareGroupsSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListHardwareGroupsRequest>
                    for ListHardwareGroupsSvc<T> {
                        type Response = super::ListHardwareGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListHardwareGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_hardware_groups(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListHardwareGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardwareGroup" => {
                    #[allow(non_camel_case_types)]
                    struct GetHardwareGroupSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetHardwareGroupRequest>
                    for GetHardwareGroupSvc<T> {
                        type Response = super::HardwareGroup;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetHardwareGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_hardware_group(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetHardwareGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardwareGroup" => {
                    #[allow(non_camel_case_types)]
                    struct CreateHardwareGroupSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::CreateHardwareGroupRequest>
                    for CreateHardwareGroupSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateHardwareGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::create_hardware_group(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateHardwareGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardwareGroup" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateHardwareGroupSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::UpdateHardwareGroupRequest>
                    for UpdateHardwareGroupSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateHardwareGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::update_hardware_group(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateHardwareGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardwareGroup" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteHardwareGroupSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::DeleteHardwareGroupRequest>
                    for DeleteHardwareGroupSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteHardwareGroupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::delete_hardware_group(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteHardwareGroupSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListHardware" => {
                    #[allow(non_camel_case_types)]
                    struct ListHardwareSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListHardwareRequest>
                    for ListHardwareSvc<T> {
                        type Response = super::ListHardwareResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListHardwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_hardware(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListHardwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetHardware" => {
                    #[allow(non_camel_case_types)]
                    struct GetHardwareSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetHardwareRequest>
                    for GetHardwareSvc<T> {
                        type Response = super::Hardware;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetHardwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_hardware(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetHardwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateHardware" => {
                    #[allow(non_camel_case_types)]
                    struct CreateHardwareSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::CreateHardwareRequest>
                    for CreateHardwareSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateHardwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::create_hardware(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateHardwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateHardware" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateHardwareSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::UpdateHardwareRequest>
                    for UpdateHardwareSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateHardwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::update_hardware(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateHardwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteHardware" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteHardwareSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::DeleteHardwareRequest>
                    for DeleteHardwareSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteHardwareRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::delete_hardware(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteHardwareSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListComments" => {
                    #[allow(non_camel_case_types)]
                    struct ListCommentsSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListCommentsRequest>
                    for ListCommentsSvc<T> {
                        type Response = super::ListCommentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListCommentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_comments(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListCommentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetComment" => {
                    #[allow(non_camel_case_types)]
                    struct GetCommentSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetCommentRequest>
                    for GetCommentSvc<T> {
                        type Response = super::Comment;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_comment(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateComment" => {
                    #[allow(non_camel_case_types)]
                    struct CreateCommentSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::CreateCommentRequest>
                    for CreateCommentSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateCommentRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::create_comment(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateCommentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListChangeLogEntries" => {
                    #[allow(non_camel_case_types)]
                    struct ListChangeLogEntriesSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListChangeLogEntriesRequest>
                    for ListChangeLogEntriesSvc<T> {
                        type Response = super::ListChangeLogEntriesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListChangeLogEntriesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_change_log_entries(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListChangeLogEntriesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetChangeLogEntry" => {
                    #[allow(non_camel_case_types)]
                    struct GetChangeLogEntrySvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetChangeLogEntryRequest>
                    for GetChangeLogEntrySvc<T> {
                        type Response = super::ChangeLogEntry;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetChangeLogEntryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_change_log_entry(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetChangeLogEntrySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListSkus" => {
                    #[allow(non_camel_case_types)]
                    struct ListSkusSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListSkusRequest>
                    for ListSkusSvc<T> {
                        type Response = super::ListSkusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSkusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_skus(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSkusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetSku" => {
                    #[allow(non_camel_case_types)]
                    struct GetSkuSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetSkuRequest>
                    for GetSkuSvc<T> {
                        type Response = super::Sku;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSkuRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_sku(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSkuSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/ListZones" => {
                    #[allow(non_camel_case_types)]
                    struct ListZonesSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::ListZonesRequest>
                    for ListZonesSvc<T> {
                        type Response = super::ListZonesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListZonesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::list_zones(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListZonesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/GetZone" => {
                    #[allow(non_camel_case_types)]
                    struct GetZoneSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::GetZoneRequest>
                    for GetZoneSvc<T> {
                        type Response = super::Zone;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetZoneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::get_zone(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetZoneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/CreateZone" => {
                    #[allow(non_camel_case_types)]
                    struct CreateZoneSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::CreateZoneRequest>
                    for CreateZoneSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateZoneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::create_zone(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateZoneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/UpdateZone" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateZoneSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::UpdateZoneRequest>
                    for UpdateZoneSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateZoneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::update_zone(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateZoneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/DeleteZone" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteZoneSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::DeleteZoneRequest>
                    for DeleteZoneSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteZoneRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::delete_zone(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteZoneSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement/SignalZoneState" => {
                    #[allow(non_camel_case_types)]
                    struct SignalZoneStateSvc<T: GdcHardwareManagement>(pub Arc<T>);
                    impl<
                        T: GdcHardwareManagement,
                    > tonic::server::UnaryService<super::SignalZoneStateRequest>
                    for SignalZoneStateSvc<T> {
                        type Response = super::super::super::super::longrunning::Operation;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SignalZoneStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GdcHardwareManagement>::signal_zone_state(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SignalZoneStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", tonic::Code::Unimplemented as i32)
                                .header(
                                    http::header::CONTENT_TYPE,
                                    tonic::metadata::GRPC_CONTENT_TYPE,
                                )
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T> Clone for GdcHardwareManagementServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "google.cloud.gdchardwaremanagement.v1alpha.GDCHardwareManagement";
    impl<T> tonic::server::NamedService for GdcHardwareManagementServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
